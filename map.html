<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Space Apps — 3D Globe (NASA Web WorldWind)</title>
  <style>
    html, body { height:100%; margin:0; background:#000; }
    /* Fullscreen starry GIF background */
    #bg {
      position: fixed; inset: 0; z-index: -1;
      background: #000 url("stars.gif") center / cover repeat;
      image-rendering: optimizeQuality;
    }
    /* Stage holds the WorldWind canvas */
    #stage { position:absolute; inset:0 }
    #wwdCanvas { position:absolute; inset:0; width:100%; height:100%; border:0; display:block }

    /* Minimal control (start/stop rotate) */
    .panel {
      position: absolute; top: 12px; left: 12px;
      display: inline-flex; gap: 8px; align-items: center;
      background: rgba(0,0,0,.45); color:#fff; padding: 8px 10px; border-radius: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; font-size: 14px;
      backdrop-filter: blur(4px);
    }
    .panel button {
      padding: 6px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,.25);
      background: rgba(255,255,255,.12); color: #fff; cursor: pointer;
    }
    .panel button:hover { background: rgba(255,255,255,.2); }

    /* Analog joystick */
    .joystick {
      position: absolute; left: 16px; bottom: 16px; width: 120px; height: 120px; border-radius: 50%;
      background: rgba(255,255,255,.06); border: 1px solid rgba(255,255,255,.15); backdrop-filter: blur(4px);
      touch-action: none; user-select: none;
    }
    .joystick .stick {
      position: absolute; left: 50%; top: 50%; width: 56px; height: 56px; margin-left: -28px; margin-top: -28px; border-radius: 50%;
      background: rgba(255,255,255,.25); border: 1px solid rgba(255,255,255,.35);
      box-shadow: 0 4px 14px rgba(0,0,0,.35);
      transition: transform 80ms ease-out;
      touch-action: none;
    }
  </style>
</head>
<body>
  <!-- Starry background (put your GIF at stars.gif) -->
  <div id="bg" aria-hidden="true"></div>

  <!-- Globe container -->
  <div id="stage">
    <canvas id="wwdCanvas"></canvas>
  </div>

  <!-- Minimal control -->
  <div class="panel">
    <span>3D Globe</span>
    <button id="toggleSpin">⏸ Stop</button>
  </div>
  
  <!-- Year/Date controls (static CSVs) -->
  <div class="panel" style="top:58px; gap:8px;">
    <label style="display:flex;align-items:center;gap:6px">
      Year:
      <select id="yearSel"></select>
    </label>
    <label style="display:flex;align-items:center;gap:6px">
      Date:
      <select id="dateSel"></select>
    </label>
    <button id="renderBtn">Render</button>
    <span id="status" style="opacity:.8"></span>
  </div>



  <!-- On‑screen joystick -->
  <div class="joystick" id="joy"><div class="stick" id="stick"></div></div>

  <!-- NASA Web WorldWind -->
  <script src="https://files.worldwind.arc.nasa.gov/artifactory/web/0.11.0/worldwind.min.js"></script>
  <script>
    // ====== Init WorldWind native globe ======
    const canvas = document.getElementById('wwdCanvas');
    let rotating = true;         // auto-rotate ON by default
    const ROTATE_SPEED = 0.03;   // degrees per frame (~1.8°/s)

    function initWorldWind() {
      if (!window.WorldWind) { console.error('WorldWind failed to load'); return null; }
      WorldWind.configuration.baseUrl = 'https://files.worldwind.arc.nasa.gov/artifactory/web/0.11.0/';
      const wwd = new WorldWind.WorldWindow('wwdCanvas');

      // Base imagery
      wwd.addLayer(new WorldWind.BMNGOneImageLayer());
      wwd.addLayer(new WorldWind.BMNGLandsatLayer());
      // Atmosphere glow (stars are the page background GIF)
      wwd.addLayer(new WorldWind.AtmosphereLayer());

      // Start zoomed in over Greece
      wwd.navigator.lookAtLocation.latitude = 37.9838;  // Athens
      wwd.navigator.lookAtLocation.longitude = 23.7275;
      wwd.navigator.range = 9e5; // ~900 km from surface for a regional view
      wwd.redraw();

      // Auto-rotate loop
      function spin() {
        if (rotating) {
          wwd.navigator.heading = (wwd.navigator.heading + ROTATE_SPEED) % 360;
          wwd.redraw();
        }
        requestAnimationFrame(spin);
      }
      requestAnimationFrame(spin);
      return wwd;
    }

    const wwd = initWorldWind();

    // ====== Configure CSVs ======
    // history covers real years (e.g., 2020–2024); prediction covers the future (e.g., 2025)
    const DATASETS = [
      { key: 'history',    url: 'no2_temp_data.csv',    prediction: false },
      { key: 'prediction', url: 'no2_prediction.csv',   prediction: true  }
    ];

    const OVERLAY_ALPHA = 0.55;

    // ====== Internals: year-indexed store ======
    const YEARS = new Map(); // year -> { label, byDate(Map date->rows), dates[], minMaxByDate(Map) }
    let currentOverlayLayer = null;

    // ---------- Utils ----------
    function parseCsv(text) {
      const lines = text.trim().split(/\r?\n/);
      if (!lines.length) return [];
      const header = lines[0].split(',').map(s=>s.trim().toLowerCase());
      const idx = {
        time: header.indexOf('time'),
        lat:  header.indexOf('latitude'),
        lon:  header.indexOf('longitude'),
        val:  header.indexOf('value'),
      };
      if (Object.values(idx).some(i => i < 0)) throw new Error('CSV must have time,latitude,longitude,value columns');
      const out = [];
      for (let i=1;i<lines.length;i++){
        const parts = lines[i].split(',');
        if (parts.length < 4) continue;
        const t = (parts[idx.time]||'').trim();
        const iso = t.length >= 10 ? t.slice(0,10) : t;
        const y = parseInt(iso.slice(0,4), 10);
        const lat = parseFloat(parts[idx.lat]);
        const lon = parseFloat(parts[idx.lon]);
        const val = parseFloat(parts[idx.val]);
        if (!isFinite(lat) || !isFinite(lon) || !isFinite(val) || !iso || !isFinite(y)) continue;
        out.push({ year: y, time: iso, lat, lon, val });
      }
      return out;
    }

    function robustMinMax(values) {
      const v = values.slice().sort((a,b)=>a-b);
      if (!v.length) return {min:0,max:1};
      const q = p => v[Math.floor(Math.min(v.length-1, Math.max(0, p*(v.length-1))))];
      const min = q(0.01), max = q(0.99);
      return min === max ? {min: min-1, max: max+1} : {min, max};
    }

    function valueToColor(val, min, max, alpha=1) {
      const t = Math.max(0, Math.min(1, (val - min) / (max - min)));
      const stops = [
        {t:0.00, c:[ 44,123,182]},
        {t:0.33, c:[171,217,233]},
        {t:0.66, c:[255,255,191]},
        {t:1.00, c:[215, 25, 28]}
      ];
      let c0=stops[0].c, c1=stops.at(-1).c, t0=0, t1=1;
      for (let i=0;i<stops.length-1;i++){
        if (t>=stops[i].t && t<=stops[i+1].t){ c0=stops[i].c; c1=stops[i+1].c; t0=stops[i].t; t1=stops[i+1].t; break; }
      }
      const k = (t - t0) / (t1 - t0);
      const r = Math.round(c0[0] + (c1[0]-c0[0])*k)/255;
      const g = Math.round(c0[1] + (c1[1]-c0[1])*k)/255;
      const b = Math.round(c0[2] + (c1[2]-c0[2])*k)/255;
      return new WorldWind.Color(r,g,b,alpha);
    }

    function paintLegend(min, max) {
      const cv = document.getElementById('legend');
      const ctx = cv.getContext('2d');
      const w=cv.width,h=cv.height;
      const img = ctx.createImageData(w,h);
      for (let x=0;x<w;x++){
        const t = x/(w-1);
        const c = valueToColor(min + t*(max-min), min, max, 1);
        const R = Math.round(c.red*255), G=Math.round(c.green*255), B=Math.round(c.blue*255);
        for (let y=0;y<h;y++){
          const i=(y*w+x)*4; img.data[i]=R; img.data[i+1]=G; img.data[i+2]=B; img.data[i+3]=255;
        }
      }
      ctx.putImageData(img,0,0);
      document.getElementById('legMin').textContent = min.toExponential(2);
      document.getElementById('legMax').textContent = max.toExponential(2);
    }

    function medianDiff(sortedVals){
      const diffs = [];
      for (let i=1;i<sortedVals.length;i++){
        const d = sortedVals[i] - sortedVals[i-1];
        if (isFinite(d) && d > 0) diffs.push(d);
      }
      diffs.sort((a,b)=>a-b);
      return diffs.length ? diffs[Math.floor(diffs.length/2)] : NaN;
    }

    // Grid cell layer (squares)
    function makeOverlayLayer(rows, min, max, title='Overlay (grid)'){
      const layer = new WorldWind.RenderableLayer(title);

      const uniqLats = Array.from(new Set(rows.map(r=>r.lat))).sort((a,b)=>a-b);
      const uniqLons = Array.from(new Set(rows.map(r=>r.lon))).sort((a,b)=>a-b);
      let dLat = medianDiff(uniqLats);
      let dLon = medianDiff(uniqLons);
      if (!isFinite(dLat) || dLat <= 0) dLat = 0.2;
      if (!isFinite(dLon) || dLon <= 0) dLon = 0.2;
      const gap = 0.0 * Math.min(dLat, dLon); // set >0 for tiny gaps
      const hLat = dLat/2 - gap/2, hLon = dLon/2 - gap/2;

      const base = new WorldWind.ShapeAttributes(null);
      base.drawOutline = false; base.applyLighting = false;

      for (const r of rows){
        const sa = new WorldWind.ShapeAttributes(base);
        sa.interiorColor = valueToColor(r.val, min, max, OVERLAY_ALPHA);
        const corners = [
          new WorldWind.Location(r.lat - hLat, r.lon - hLon),
          new WorldWind.Location(r.lat - hLat, r.lon + hLon),
          new WorldWind.Location(r.lat + hLat, r.lon + hLon),
          new WorldWind.Location(r.lat + hLat, r.lon - hLon),
        ];
        const poly = new WorldWind.SurfacePolygon(corners, sa);
        layer.addRenderable(poly);
      }
      return layer;
    }

    function removeCurrentLayer(){
      if (currentOverlayLayer){ wwd.removeLayer(currentOverlayLayer); currentOverlayLayer=null; wwd.redraw(); }
    }

    // ---------- Render (by Year then Date) ----------
    function renderSelected(){
      const yStr = document.getElementById('yearSel').value;
      const date = document.getElementById('dateSel').value;
      const entry = YEARS.get(parseInt(yStr,10));
      if (!entry){ document.getElementById('status').textContent='Year not loaded'; return; }
      const rows = entry.byDate.get(date) || [];
      if (!rows.length){
        document.getElementById('status').textContent = `No rows for ${date}`;
        removeCurrentLayer(); return;
      }
      const mm = entry.minMaxByDate.get(date) || robustMinMax(rows.map(r=>r.val));
      removeCurrentLayer();
      currentOverlayLayer = makeOverlayLayer(rows, mm.min, mm.max, `${entry.label} ${date}`);
      wwd.addLayer(currentOverlayLayer); wwd.redraw();
      paintLegend(mm.min, mm.max);
      document.getElementById('status').textContent = `Rendered ${rows.length} points (${entry.label} — ${date})`;
    }

    // ---------- Load datasets and index into YEARS ----------
    async function loadDataset(def){
      const res = await fetch(def.url, { cache: 'no-store' });
      if (!res.ok) throw new Error(`Failed to fetch ${def.url}: ${res.status}`);
      const rows = parseCsv(await res.text());

      // group by year, then date
      const byYear = new Map();
      for (const r of rows){
        let y = byYear.get(r.year);
        if (!y) { y = new Map(); byYear.set(r.year, y); }
        const arr = y.get(r.time) || []; arr.push(r); y.set(r.time, arr);
      }

      for (const [year, byDate] of byYear.entries()){
        const dates = Array.from(byDate.keys()).sort();
        const minMaxByDate = new Map();
        for (const d of dates){
          const vs = byDate.get(d).map(x=>x.val).filter(Number.isFinite);
          minMaxByDate.set(d, robustMinMax(vs));
        }
        const existing = YEARS.get(year);
        const label = def.prediction ? `${year} (Prediction)` : `${year}`;
        if (existing){
          // merge if two files provide same year (rare)
          for (const d of dates){
            const prev = existing.byDate.get(d) || [];
            existing.byDate.set(d, prev.concat(byDate.get(d)));
            const mmThis = robustMinMax((prev.concat(byDate.get(d))).map(x=>x.val));
            existing.minMaxByDate.set(d, mmThis);
            if (!existing.dates.includes(d)) existing.dates.push(d);
          }
          existing.dates.sort();
          if (def.prediction) existing.label = label;
        } else {
          YEARS.set(year, { label, byDate, dates, minMaxByDate });
        }
      }
    }

    async function loadAllDatasets(){
      const yearSel = document.getElementById('yearSel');
      document.getElementById('status').textContent = 'Loading datasets…';
      for (const def of DATASETS){
        try { await loadDataset(def); } catch(e){ console.error(e); }
      }
      const years = Array.from(YEARS.keys()).sort((a,b)=>a-b);
      yearSel.innerHTML = '';
      for (const y of years){
        const opt = document.createElement('option');
        opt.value = String(y);
        opt.textContent = YEARS.get(y).label;
        yearSel.appendChild(opt);
      }
      yearSel.addEventListener('change', onYearChange);
      onYearChange();
    }

    function onYearChange(){
      const yStr = document.getElementById('yearSel').value;
      const entry = YEARS.get(parseInt(yStr,10));
      const dateSel = document.getElementById('dateSel');
      dateSel.innerHTML = '';
      for (const d of entry.dates){
        const opt = document.createElement('option');
        opt.value = d; opt.textContent = d;
        dateSel.appendChild(opt);
      }
      document.getElementById('status').textContent = `Year ${entry.label}: ${entry.dates.length} day(s)`;
      renderSelected();
    }

    document.getElementById('renderBtn').addEventListener('click', renderSelected);

    // Optional: center on Greece initially
    (function flyToGreece(){
      if (!wwd) return;
      wwd.navigator.lookAtLocation.latitude = 39.0;
      wwd.navigator.lookAtLocation.longitude = 23.5;
      wwd.navigator.range = 8.5e5; wwd.redraw();
    })();

    // Kickoff dataset loading
    loadAllDatasets();
    // ====== UI: Start/Stop auto-rotate ======
    const btn = document.getElementById('toggleSpin');
    btn.addEventListener('click', () => {
      rotating = !rotating;
      btn.textContent = rotating ? '⏸ Stop' : '⟳ Auto-rotate';
    });

    // ====== Analog joystick to move the globe (pan) ======
    const joy = document.getElementById('joy');
    const stick = document.getElementById('stick');
    const R = 50; // radius in px for max deflection
    let active = false, joyCenter = {x:0,y:0}, vec = {x:0,y:0};

    function setStick(x, y){
      // constrain to circle of radius R
      const dx = x - joyCenter.x, dy = y - joyCenter.y;
      const len = Math.hypot(dx, dy);
      const clamped = len > R ? { x: dx * R/len, y: dy * R/len } : { x: dx, y: dy };
      stick.style.transform = `translate(${clamped.x}px, ${clamped.y}px)`;
      vec.x = clamped.x / R; // -1..1
      vec.y = clamped.y / R; // -1..1
    }

    function resetStick(){ stick.style.transform = 'translate(0,0)'; vec.x = vec.y = 0; }

    function pageToLocal(ev){ const r = joy.getBoundingClientRect(); return { x: ev.clientX - r.left - r.width/2, y: ev.clientY - r.top - r.height/2, cx: r.left + r.width/2, cy: r.top + r.height/2 }; }

    joy.addEventListener('pointerdown', ev => {
      active = true; joy.setPointerCapture(ev.pointerId);
      const p = pageToLocal(ev); joyCenter = { x: p.cx - joy.getBoundingClientRect().left, y: p.cy - joy.getBoundingClientRect().top };
      setStick(p.x + joy.getBoundingClientRect().width/2, p.y + joy.getBoundingClientRect().height/2);
      rotating = false; // pause auto-rotate while user controls
    });
    joy.addEventListener('pointermove', ev => { if (!active) return; const p = pageToLocal(ev); setStick(p.cx, p.cy); });
    joy.addEventListener('pointerup', ev => { active = false; resetStick(); });
    joy.addEventListener('pointercancel', () => { active = false; resetStick(); });

    // Apply joystick vector each frame
    const PAN_SPEED = 0.15; // degrees per second at full deflection (approx)
    let lastTs = performance.now();
    function joystickLoop(ts){
      const dt = (ts - lastTs) / 1000; lastTs = ts;
      if (wwd && (Math.abs(vec.x) > 0.01 || Math.abs(vec.y) > 0.01)){
        // Adjust longitude and latitude; invert Y so up moves north
        const lat = wwd.navigator.lookAtLocation.latitude - vec.y * PAN_SPEED * dt * 60; // scaled by 60 fps nominal
        let lon = wwd.navigator.lookAtLocation.longitude + vec.x * PAN_SPEED * dt * 60 / Math.max(0.2, Math.cos(lat*Math.PI/180));
        // Clamp latitude to avoid poles
        const clampedLat = Math.max(-85, Math.min(85, lat));
        if (lon < -180) lon += 360; else if (lon > 180) lon -= 360;
        wwd.navigator.lookAtLocation.latitude = clampedLat;
        wwd.navigator.lookAtLocation.longitude = lon;
        wwd.redraw();
      }
      requestAnimationFrame(joystickLoop);
    }
    requestAnimationFrame(joystickLoop);
  </script>
</body>
</html>
